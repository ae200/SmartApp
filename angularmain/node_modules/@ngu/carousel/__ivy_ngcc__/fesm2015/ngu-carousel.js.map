{"version":3,"sources":["C:/Users/Administrator/Desktop/work/angular/smartapp/node_modules/@ngu/carousel/fesm2015/ngu-carousel.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBA2DC,CAAC,AAM2B;;;;;;;;;;;oBAE5B,CAAC,AAM2B;;;;;;;;;;;oBAE5B,CAAC,AAM2B;;;;;;;;;;;oBAE5B,CAAC,AAM4B;;;;;;;oIAK7B;;;;;;;;;;EAGC,0FAM0B;;;;;;;;;2HAO3B;;;;;;;;;;EAGC,oGAOoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;43DAiqBrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAOC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAqCwB,AAUvB;;;;;;;;;;;;;;;;;;;;;;;;;;;cAOF;;;kDAGiD,AAO7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAMpB;;;kDAGiD,AAO7B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAGpB,CAAC,AA2BoB","file":"ngu-carousel.js","sourcesContent":["import { __decorate, __param } from 'tslib';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { Directive, TemplateRef, ViewContainerRef, EventEmitter, isDevMode, ElementRef, Renderer2, IterableDiffers, Inject, PLATFORM_ID, ChangeDetectorRef, Input, Output, ContentChildren, ViewChild, ContentChild, Component, ChangeDetectionStrategy, HostBinding, NgModule } from '@angular/core';\nimport { Subject, Observable, of, fromEvent, interval, merge, EMPTY } from 'rxjs';\nimport { takeUntil, mapTo, startWith, switchMap } from 'rxjs/operators';\n\nclass NguCarouselStore {\r\n    constructor(touch = new Touch(), vertical = new Vertical(), interval, transform = new Transfrom(), button, visibleItems, deviceType, type = 'fixed', token = '', items = 0, load = 0, deviceWidth = 0, carouselWidth = 0, itemWidth = 0, slideItems = 0, itemWidthPer = 0, itemLength = 0, currentSlide = 0, easing = 'cubic-bezier(0, 0, 0.2, 1)', speed = 200, loop = false, dexVal = 0, touchTransform = 0, isEnd = false, isFirst = true, isLast = false, RTL = false, point = true, velocity = 1) {\r\n        this.touch = touch;\r\n        this.vertical = vertical;\r\n        this.interval = interval;\r\n        this.transform = transform;\r\n        this.button = button;\r\n        this.visibleItems = visibleItems;\r\n        this.deviceType = deviceType;\r\n        this.type = type;\r\n        this.token = token;\r\n        this.items = items;\r\n        this.load = load;\r\n        this.deviceWidth = deviceWidth;\r\n        this.carouselWidth = carouselWidth;\r\n        this.itemWidth = itemWidth;\r\n        this.slideItems = slideItems;\r\n        this.itemWidthPer = itemWidthPer;\r\n        this.itemLength = itemLength;\r\n        this.currentSlide = currentSlide;\r\n        this.easing = easing;\r\n        this.speed = speed;\r\n        this.loop = loop;\r\n        this.dexVal = dexVal;\r\n        this.touchTransform = touchTransform;\r\n        this.isEnd = isEnd;\r\n        this.isFirst = isFirst;\r\n        this.isLast = isLast;\r\n        this.RTL = RTL;\r\n        this.point = point;\r\n        this.velocity = velocity;\r\n    }\r\n}\r\nclass ItemsControl {\r\n}\r\nclass Vertical {\r\n}\r\nclass NguButton {\r\n}\r\nclass Touch {\r\n}\r\nclass Transfrom {\r\n    constructor(xs = 0, sm = 0, md = 0, lg = 0, all = 0) {\r\n        this.xs = xs;\r\n        this.sm = sm;\r\n        this.md = md;\r\n        this.lg = lg;\r\n        this.all = all;\r\n    }\r\n}\r\nclass NguCarouselConfig {\r\n}\r\nclass NguCarouselOutletContext {\r\n    constructor(data) {\r\n        this.$implicit = data;\r\n    }\r\n}\n\nlet NguCarouselItemDirective = class NguCarouselItemDirective {\r\n};\r\nNguCarouselItemDirective = __decorate([\r\n    Directive({\r\n        // tslint:disable-next-line:directive-selector\r\n        selector: '[NguCarouselItem]'\r\n    })\r\n], NguCarouselItemDirective);\r\nlet NguCarouselNextDirective = class NguCarouselNextDirective {\r\n};\r\nNguCarouselNextDirective = __decorate([\r\n    Directive({\r\n        // tslint:disable-next-line:directive-selector\r\n        selector: '[NguCarouselNext]'\r\n    })\r\n], NguCarouselNextDirective);\r\nlet NguCarouselPrevDirective = class NguCarouselPrevDirective {\r\n};\r\nNguCarouselPrevDirective = __decorate([\r\n    Directive({\r\n        // tslint:disable-next-line:directive-selector\r\n        selector: '[NguCarouselPrev]'\r\n    })\r\n], NguCarouselPrevDirective);\r\nlet NguCarouselPointDirective = class NguCarouselPointDirective {\r\n};\r\nNguCarouselPointDirective = __decorate([\r\n    Directive({\r\n        // tslint:disable-next-line:directive-selector\r\n        selector: '[NguCarouselPoint]'\r\n    })\r\n], NguCarouselPointDirective);\r\nlet NguCarouselDefDirective = class NguCarouselDefDirective {\r\n    constructor(template) {\r\n        this.template = template;\r\n    }\r\n};\r\nNguCarouselDefDirective.ctorParameters = () => [\r\n    { type: TemplateRef }\r\n];\r\nNguCarouselDefDirective = __decorate([\r\n    Directive({\r\n        // tslint:disable-next-line:directive-selector\r\n        selector: '[nguCarouselDef]'\r\n    })\r\n], NguCarouselDefDirective);\r\nlet NguCarouselOutlet = \r\n// tslint:disable-next-line:directive-class-suffix\r\nclass NguCarouselOutlet {\r\n    constructor(viewContainer) {\r\n        this.viewContainer = viewContainer;\r\n    }\r\n};\r\nNguCarouselOutlet.ctorParameters = () => [\r\n    { type: ViewContainerRef }\r\n];\r\nNguCarouselOutlet = __decorate([\r\n    Directive({\r\n        // tslint:disable-next-line:directive-selector\r\n        selector: '[nguCarouselOutlet]'\r\n    })\r\n    // tslint:disable-next-line:directive-class-suffix\r\n], NguCarouselOutlet);\n\n// @dynamic\r\nlet NguCarousel = \r\n// @dynamic\r\n// tslint:disable-next-line:component-class-suffix\r\nclass NguCarousel extends NguCarouselStore {\r\n    constructor(_el, _renderer, _differs, platformId, cdr) {\r\n        super();\r\n        this._el = _el;\r\n        this._renderer = _renderer;\r\n        this._differs = _differs;\r\n        this.platformId = platformId;\r\n        this.cdr = cdr;\r\n        this.withAnim = true;\r\n        this.isHovered = false;\r\n        this.carouselLoad = new EventEmitter();\r\n        // tslint:disable-next-line:no-output-on-prefix\r\n        this.onMove = new EventEmitter();\r\n        this._intervalController$ = new Subject();\r\n        this.pointNumbers = [];\r\n    }\r\n    get dataSource() {\r\n        return this._dataSource;\r\n    }\r\n    set dataSource(data) {\r\n        if (data) {\r\n            this._switchDataSource(data);\r\n        }\r\n    }\r\n    /** The setter is used to catch the button if the button has ngIf\r\n     * issue id #91\r\n     */\r\n    set nextBtn(btn) {\r\n        this.listener2 && this.listener2();\r\n        if (btn) {\r\n            this.listener2 = this._renderer.listen(btn.nativeElement, 'click', () => this._carouselScrollOne(1));\r\n        }\r\n    }\r\n    /** The setter is used to catch the button if the button has ngIf\r\n     * issue id #91\r\n     */\r\n    set prevBtn(btn) {\r\n        this.listener1 && this.listener1();\r\n        if (btn) {\r\n            this.listener1 = this._renderer.listen(btn.nativeElement, 'click', () => this._carouselScrollOne(0));\r\n        }\r\n    }\r\n    /**\r\n     * Tracking function that will be used to check the differences in data changes. Used similarly\r\n     * to `ngFor` `trackBy` function. Optimize Items operations by identifying a Items based on its data\r\n     * relative to the function to know if a Items should be added/removed/moved.\r\n     * Accepts a function that takes two parameters, `index` and `item`.\r\n     */\r\n    get trackBy() {\r\n        return this._trackByFn;\r\n    }\r\n    set trackBy(fn) {\r\n        if (isDevMode() && fn != null && typeof fn !== 'function' && console && console.warn) {\r\n            console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);\r\n        }\r\n        this._trackByFn = fn;\r\n    }\r\n    ngOnInit() {\r\n        this._dataDiffer = this._differs.find([]).create((_i, item) => {\r\n            return this.trackBy ? this.trackBy(item.dataIndex, item.data) : item;\r\n        });\r\n    }\r\n    ngDoCheck() {\r\n        this.arrayChanges = this._dataDiffer.diff(this.dataSource);\r\n        if (this.arrayChanges && this._defDirec) {\r\n            this._observeRenderChanges();\r\n        }\r\n    }\r\n    _switchDataSource(dataSource) {\r\n        this._dataSource = dataSource;\r\n        if (this._defDirec) {\r\n            this._observeRenderChanges();\r\n        }\r\n    }\r\n    _observeRenderChanges() {\r\n        let dataStream;\r\n        if (this._dataSource instanceof Observable) {\r\n            dataStream = this._dataSource;\r\n        }\r\n        else if (Array.isArray(this._dataSource)) {\r\n            dataStream = of(this._dataSource);\r\n        }\r\n        if (dataStream) {\r\n            this._dataSubscription = dataStream\r\n                .pipe(takeUntil(this._intervalController$))\r\n                .subscribe(data => {\r\n                this.renderNodeChanges(data);\r\n                this.isLast = false;\r\n            });\r\n        }\r\n    }\r\n    renderNodeChanges(data, viewContainer = this._nodeOutlet.viewContainer) {\r\n        if (!this.arrayChanges)\r\n            return;\r\n        this.arrayChanges.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\r\n            const node = this._getNodeDef(data[currentIndex], currentIndex);\r\n            if (item.previousIndex == null) {\r\n                const context = new NguCarouselOutletContext(data[currentIndex]);\r\n                context.index = currentIndex;\r\n                viewContainer.createEmbeddedView(node.template, context, currentIndex);\r\n            }\r\n            else if (currentIndex == null) {\r\n                viewContainer.remove(adjustedPreviousIndex);\r\n            }\r\n            else {\r\n                const view = viewContainer.get(adjustedPreviousIndex);\r\n                viewContainer.move(view, currentIndex);\r\n            }\r\n        });\r\n        this._updateItemIndexContext();\r\n        if (this.carousel) {\r\n            this._storeCarouselData();\r\n        }\r\n    }\r\n    /**\r\n     * Updates the index-related context for each row to reflect any changes in the index of the rows,\r\n     * e.g. first/last/even/odd.\r\n     */\r\n    _updateItemIndexContext() {\r\n        const viewContainer = this._nodeOutlet.viewContainer;\r\n        for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\r\n            const viewRef = viewContainer.get(renderIndex);\r\n            const context = viewRef.context;\r\n            context.count = count;\r\n            context.first = renderIndex === 0;\r\n            context.last = renderIndex === count - 1;\r\n            context.even = renderIndex % 2 === 0;\r\n            context.odd = !context.even;\r\n            context.index = renderIndex;\r\n        }\r\n    }\r\n    _getNodeDef(data, i) {\r\n        if (this._defDirec.length === 1) {\r\n            return this._defDirec.first;\r\n        }\r\n        const nodeDef = this._defDirec.find(def => def.when && def.when(i, data)) || this._defaultNodeDef;\r\n        return nodeDef;\r\n    }\r\n    ngAfterViewInit() {\r\n        this.carousel = this._el.nativeElement;\r\n        this._inputValidation();\r\n        this.carouselCssNode = this._createStyleElem();\r\n        if (isPlatformBrowser(this.platformId)) {\r\n            this._carouselInterval();\r\n            if (!this.vertical.enabled) {\r\n                this._touch();\r\n            }\r\n            this.listener3 = this._renderer.listen('window', 'resize', event => {\r\n                this._onResizing(event);\r\n            });\r\n            this._onWindowScrolling();\r\n        }\r\n    }\r\n    ngAfterContentInit() {\r\n        this._observeRenderChanges();\r\n        this.cdr.markForCheck();\r\n    }\r\n    _inputValidation() {\r\n        this.type = this.inputs.grid.all !== 0 ? 'fixed' : 'responsive';\r\n        this.loop = this.inputs.loop || false;\r\n        this.inputs.easing = this.inputs.easing || 'cubic-bezier(0, 0, 0.2, 1)';\r\n        this.touch.active = this.inputs.touch || false;\r\n        this.RTL = this.inputs.RTL ? true : false;\r\n        this.interval = this.inputs.interval || null;\r\n        this.velocity = typeof this.inputs.velocity === 'number' ? this.inputs.velocity : this.velocity;\r\n        if (this.inputs.vertical && this.inputs.vertical.enabled) {\r\n            this.vertical.enabled = this.inputs.vertical.enabled;\r\n            this.vertical.height = this.inputs.vertical.height;\r\n        }\r\n        this.directionSym = this.RTL ? '' : '-';\r\n        this.point =\r\n            this.inputs.point && typeof this.inputs.point.visible !== 'undefined'\r\n                ? this.inputs.point.visible\r\n                : true;\r\n        this._carouselSize();\r\n    }\r\n    ngOnDestroy() {\r\n        this.carouselInt && this.carouselInt.unsubscribe();\r\n        this._intervalController$.unsubscribe();\r\n        this.carouselLoad.complete();\r\n        this.onMove.complete();\r\n        /** remove listeners */\r\n        clearTimeout(this.onScrolling);\r\n        for (let i = 1; i <= 4; i++) {\r\n            const str = `listener${i}`;\r\n            this[str] && this[str]();\r\n        }\r\n    }\r\n    _onResizing(event) {\r\n        clearTimeout(this.onResize);\r\n        this.onResize = setTimeout(() => {\r\n            if (this.deviceWidth !== event.target.outerWidth) {\r\n                this._setStyle(this.nguItemsContainer.nativeElement, 'transition', ``);\r\n                this._storeCarouselData();\r\n            }\r\n        }, 500);\r\n    }\r\n    /** Get Touch input */\r\n    _touch() {\r\n        if (this.inputs.touch) {\r\n            import('hammerjs').then(() => {\r\n                const hammertime = new Hammer(this.touchContainer.nativeElement);\r\n                hammertime.get('pan').set({ direction: Hammer.DIRECTION_HORIZONTAL });\r\n                hammertime.on('panstart', (ev) => {\r\n                    this.carouselWidth = this.nguItemsContainer.nativeElement.offsetWidth;\r\n                    this.touchTransform = this.transform[this.deviceType];\r\n                    this.dexVal = 0;\r\n                    this._setStyle(this.nguItemsContainer.nativeElement, 'transition', '');\r\n                });\r\n                if (this.vertical.enabled) {\r\n                    hammertime.on('panup', (ev) => {\r\n                        this._touchHandling('panleft', ev);\r\n                    });\r\n                    hammertime.on('pandown', (ev) => {\r\n                        this._touchHandling('panright', ev);\r\n                    });\r\n                }\r\n                else {\r\n                    hammertime.on('panleft', (ev) => {\r\n                        this._touchHandling('panleft', ev);\r\n                    });\r\n                    hammertime.on('panright', (ev) => {\r\n                        this._touchHandling('panright', ev);\r\n                    });\r\n                }\r\n                hammertime.on('panend pancancel', (ev) => {\r\n                    if (Math.abs(ev.velocity) >= this.velocity) {\r\n                        this.touch.velocity = ev.velocity;\r\n                        let direc = 0;\r\n                        if (!this.RTL) {\r\n                            direc = this.touch.swipe === 'panright' ? 0 : 1;\r\n                        }\r\n                        else {\r\n                            direc = this.touch.swipe === 'panright' ? 1 : 0;\r\n                        }\r\n                        this._carouselScrollOne(direc);\r\n                    }\r\n                    else {\r\n                        this.dexVal = 0;\r\n                        this._setStyle(this.nguItemsContainer.nativeElement, 'transition', 'transform 324ms cubic-bezier(0, 0, 0.2, 1)');\r\n                        this._setStyle(this.nguItemsContainer.nativeElement, 'transform', '');\r\n                    }\r\n                });\r\n                hammertime.on('hammer.input', ev => {\r\n                    // allow nested touch events to no propagate, this may have other side affects but works for now.\r\n                    // TODO: It is probably better to check the source element of the event and only apply the handle to the correct carousel\r\n                    ev.srcEvent.stopPropagation();\r\n                });\r\n            });\r\n        }\r\n    }\r\n    /** handle touch input */\r\n    _touchHandling(e, ev) {\r\n        // vertical touch events seem to cause to panstart event with an odd delta\r\n        // and a center of {x:0,y:0} so this will ignore them\r\n        if (ev.center.x === 0) {\r\n            return;\r\n        }\r\n        ev = Math.abs(this.vertical.enabled ? ev.deltaY : ev.deltaX);\r\n        let valt = ev - this.dexVal;\r\n        valt =\r\n            this.type === 'responsive'\r\n                ? (Math.abs(ev - this.dexVal) /\r\n                    (this.vertical.enabled ? this.vertical.height : this.carouselWidth)) *\r\n                    100\r\n                : valt;\r\n        this.dexVal = ev;\r\n        this.touch.swipe = e;\r\n        this._setTouchTransfrom(e, valt);\r\n        this._setTransformFromTouch();\r\n    }\r\n    _setTouchTransfrom(e, valt) {\r\n        const condition = this.RTL ? 'panright' : 'panleft';\r\n        this.touchTransform = e === condition ? valt + this.touchTransform : this.touchTransform - valt;\r\n    }\r\n    _setTransformFromTouch() {\r\n        if (this.touchTransform < 0) {\r\n            this.touchTransform = 0;\r\n        }\r\n        const type = this.type === 'responsive' ? '%' : 'px';\r\n        this._setStyle(this.nguItemsContainer.nativeElement, 'transform', this.vertical.enabled\r\n            ? `translate3d(0, ${this.directionSym}${this.touchTransform}${type}, 0)`\r\n            : `translate3d(${this.directionSym}${this.touchTransform}${type}, 0, 0)`);\r\n    }\r\n    /** this fn used to disable the interval when it is not on the viewport */\r\n    _onWindowScrolling() {\r\n        const top = this.carousel.offsetTop;\r\n        const scrollY = window.scrollY;\r\n        const heightt = window.innerHeight;\r\n        const carouselHeight = this.carousel.offsetHeight;\r\n        const isCarouselOnScreen = top <= scrollY + heightt - carouselHeight / 4 && top + carouselHeight / 2 >= scrollY;\r\n        if (isCarouselOnScreen) {\r\n            this._intervalController$.next(1);\r\n        }\r\n        else {\r\n            this._intervalController$.next(0);\r\n        }\r\n    }\r\n    /** store data based on width of the screen for the carousel */\r\n    _storeCarouselData() {\r\n        this.deviceWidth = isPlatformBrowser(this.platformId) ? window.innerWidth : 1200;\r\n        this.carouselWidth = this.carouselMain1.nativeElement.offsetWidth;\r\n        if (this.type === 'responsive') {\r\n            this.deviceType =\r\n                this.deviceWidth >= 1200\r\n                    ? 'lg'\r\n                    : this.deviceWidth >= 992\r\n                        ? 'md'\r\n                        : this.deviceWidth >= 768\r\n                            ? 'sm'\r\n                            : 'xs';\r\n            this.items = this.inputs.grid[this.deviceType];\r\n            this.itemWidth = this.carouselWidth / this.items;\r\n        }\r\n        else {\r\n            this.items = Math.trunc(this.carouselWidth / this.inputs.grid.all);\r\n            this.itemWidth = this.inputs.grid.all;\r\n            this.deviceType = 'all';\r\n        }\r\n        this.slideItems = +(this.inputs.slide < this.items ? this.inputs.slide : this.items);\r\n        this.load = this.inputs.load >= this.slideItems ? this.inputs.load : this.slideItems;\r\n        this.speed = this.inputs.speed && this.inputs.speed > -1 ? this.inputs.speed : 400;\r\n        this._carouselPoint();\r\n    }\r\n    /** Used to reset the carousel */\r\n    reset(withOutAnimation) {\r\n        withOutAnimation && (this.withAnim = false);\r\n        this.carouselCssNode.innerHTML = '';\r\n        this.moveTo(0);\r\n        this._carouselPoint();\r\n    }\r\n    /** Init carousel point */\r\n    _carouselPoint() {\r\n        const Nos = this.dataSource.length - (this.items - this.slideItems);\r\n        this.pointIndex = Math.ceil(Nos / this.slideItems);\r\n        const pointers = [];\r\n        if (this.pointIndex > 1 || !this.inputs.point.hideOnSingleSlide) {\r\n            for (let i = 0; i < this.pointIndex; i++) {\r\n                pointers.push(i);\r\n            }\r\n        }\r\n        this.pointNumbers = pointers;\r\n        this._carouselPointActiver();\r\n        if (this.pointIndex <= 1) {\r\n            this._btnBoolean(1, 1);\r\n        }\r\n        else {\r\n            if (this.currentSlide === 0 && !this.loop) {\r\n                this._btnBoolean(1, 0);\r\n            }\r\n            else {\r\n                this._btnBoolean(0, 0);\r\n            }\r\n        }\r\n    }\r\n    /** change the active point in carousel */\r\n    _carouselPointActiver() {\r\n        const i = Math.ceil(this.currentSlide / this.slideItems);\r\n        this.activePoint = i;\r\n        this.cdr.markForCheck();\r\n    }\r\n    /** this function is used to scoll the carousel when point is clicked */\r\n    moveTo(slide, withOutAnimation) {\r\n        // slide = slide - 1;\r\n        withOutAnimation && (this.withAnim = false);\r\n        if (this.activePoint !== slide && slide < this.pointIndex) {\r\n            let slideremains;\r\n            const btns = this.currentSlide < slide ? 1 : 0;\r\n            switch (slide) {\r\n                case 0:\r\n                    this._btnBoolean(1, 0);\r\n                    slideremains = slide * this.slideItems;\r\n                    break;\r\n                case this.pointIndex - 1:\r\n                    this._btnBoolean(0, 1);\r\n                    slideremains = this.dataSource.length - this.items;\r\n                    break;\r\n                default:\r\n                    this._btnBoolean(0, 0);\r\n                    slideremains = slide * this.slideItems;\r\n            }\r\n            this._carouselScrollTwo(btns, slideremains, this.speed);\r\n        }\r\n    }\r\n    /** set the style of the carousel based the inputs data */\r\n    _carouselSize() {\r\n        this.token = this._generateID();\r\n        let dism = '';\r\n        this.styleid = `.${this.token} > .ngucarousel > .ngu-touch-container > .ngucarousel-items`;\r\n        if (this.inputs.custom === 'banner') {\r\n            this._renderer.addClass(this.carousel, 'banner');\r\n        }\r\n        if (this.inputs.animation === 'lazy') {\r\n            dism += `${this.styleid} > .item {transition: transform .6s ease;}`;\r\n        }\r\n        let itemStyle = '';\r\n        if (this.vertical.enabled) {\r\n            const itemWidthXS = `${this.styleid} > .item {height: ${this.vertical.height /\r\n                +this.inputs.grid.xs}px}`;\r\n            const itemWidthSM = `${this.styleid} > .item {height: ${this.vertical.height /\r\n                +this.inputs.grid.sm}px}`;\r\n            const itemWidthMD = `${this.styleid} > .item {height: ${this.vertical.height /\r\n                +this.inputs.grid.md}px}`;\r\n            const itemWidthLG = `${this.styleid} > .item {height: ${this.vertical.height /\r\n                +this.inputs.grid.lg}px}`;\r\n            itemStyle = `@media (max-width:767px){${itemWidthXS}}\r\n                    @media (min-width:768px){${itemWidthSM}}\r\n                    @media (min-width:992px){${itemWidthMD}}\r\n                    @media (min-width:1200px){${itemWidthLG}}`;\r\n        }\r\n        else if (this.type === 'responsive') {\r\n            const itemWidthXS = this.inputs.type === 'mobile'\r\n                ? `${this.styleid} .item {flex: 0 0 ${95 / +this.inputs.grid.xs}%; width: ${95 /\r\n                    +this.inputs.grid.xs}%;}`\r\n                : `${this.styleid} .item {flex: 0 0 ${100 / +this.inputs.grid.xs}%; width: ${100 /\r\n                    +this.inputs.grid.xs}%;}`;\r\n            const itemWidthSM = `${this.styleid} > .item {flex: 0 0 ${100 /\r\n                +this.inputs.grid.sm}%; width: ${100 / +this.inputs.grid.sm}%}`;\r\n            const itemWidthMD = `${this.styleid} > .item {flex: 0 0 ${100 /\r\n                +this.inputs.grid.md}%; width: ${100 / +this.inputs.grid.md}%}`;\r\n            const itemWidthLG = `${this.styleid} > .item {flex: 0 0 ${100 /\r\n                +this.inputs.grid.lg}%; width: ${100 / +this.inputs.grid.lg}%}`;\r\n            itemStyle = `@media (max-width:767px){${itemWidthXS}}\r\n                    @media (min-width:768px){${itemWidthSM}}\r\n                    @media (min-width:992px){${itemWidthMD}}\r\n                    @media (min-width:1200px){${itemWidthLG}}`;\r\n        }\r\n        else {\r\n            itemStyle = `${this.styleid} .item {flex: 0 0 ${this.inputs.grid.all}px; width: ${this.inputs.grid.all}px;}`;\r\n        }\r\n        this._renderer.addClass(this.carousel, this.token);\r\n        if (this.vertical.enabled) {\r\n            this._renderer.addClass(this.nguItemsContainer.nativeElement, 'nguvertical');\r\n            this._renderer.setStyle(this.carouselMain1.nativeElement, 'height', `${this.vertical.height}px`);\r\n        }\r\n        // tslint:disable-next-line:no-unused-expression\r\n        this.RTL && !this.vertical.enabled && this._renderer.addClass(this.carousel, 'ngurtl');\r\n        this._createStyleElem(`${dism} ${itemStyle}`);\r\n        this._storeCarouselData();\r\n    }\r\n    /** logic to scroll the carousel step 1 */\r\n    _carouselScrollOne(Btn) {\r\n        let itemSpeed = this.speed;\r\n        let translateXval = 0;\r\n        let currentSlide = 0;\r\n        const touchMove = Math.ceil(this.dexVal / this.itemWidth);\r\n        this._setStyle(this.nguItemsContainer.nativeElement, 'transform', '');\r\n        if (this.pointIndex === 1) {\r\n            return;\r\n        }\r\n        else if (Btn === 0 && ((!this.loop && !this.isFirst) || this.loop)) {\r\n            const currentSlideD = this.currentSlide - this.slideItems;\r\n            const MoveSlide = currentSlideD + this.slideItems;\r\n            this._btnBoolean(0, 1);\r\n            if (this.currentSlide === 0) {\r\n                currentSlide = this.dataSource.length - this.items;\r\n                itemSpeed = 400;\r\n                this._btnBoolean(0, 1);\r\n            }\r\n            else if (this.slideItems >= MoveSlide) {\r\n                currentSlide = translateXval = 0;\r\n                this._btnBoolean(1, 0);\r\n            }\r\n            else {\r\n                this._btnBoolean(0, 0);\r\n                if (touchMove > this.slideItems) {\r\n                    currentSlide = this.currentSlide - touchMove;\r\n                    itemSpeed = 200;\r\n                }\r\n                else {\r\n                    currentSlide = this.currentSlide - this.slideItems;\r\n                }\r\n            }\r\n            this._carouselScrollTwo(Btn, currentSlide, itemSpeed);\r\n        }\r\n        else if (Btn === 1 && ((!this.loop && !this.isLast) || this.loop)) {\r\n            if (this.dataSource.length <= this.currentSlide + this.items + this.slideItems &&\r\n                !this.isLast) {\r\n                currentSlide = this.dataSource.length - this.items;\r\n                this._btnBoolean(0, 1);\r\n            }\r\n            else if (this.isLast) {\r\n                currentSlide = translateXval = 0;\r\n                itemSpeed = 400;\r\n                this._btnBoolean(1, 0);\r\n            }\r\n            else {\r\n                this._btnBoolean(0, 0);\r\n                if (touchMove > this.slideItems) {\r\n                    currentSlide = this.currentSlide + this.slideItems + (touchMove - this.slideItems);\r\n                    itemSpeed = 200;\r\n                }\r\n                else {\r\n                    currentSlide = this.currentSlide + this.slideItems;\r\n                }\r\n            }\r\n            this._carouselScrollTwo(Btn, currentSlide, itemSpeed);\r\n        }\r\n    }\r\n    /** logic to scroll the carousel step 2 */\r\n    _carouselScrollTwo(Btn, currentSlide, itemSpeed) {\r\n        // tslint:disable-next-line:no-unused-expression\r\n        if (this.dexVal !== 0) {\r\n            const val = Math.abs(this.touch.velocity);\r\n            let somt = Math.floor((this.dexVal / val / this.dexVal) * (this.deviceWidth - this.dexVal));\r\n            somt = somt > itemSpeed ? itemSpeed : somt;\r\n            itemSpeed = somt < 200 ? 200 : somt;\r\n            this.dexVal = 0;\r\n        }\r\n        if (this.withAnim) {\r\n            this._setStyle(this.nguItemsContainer.nativeElement, 'transition', `transform ${itemSpeed}ms ${this.inputs.easing}`);\r\n            this.inputs.animation &&\r\n                this._carouselAnimator(Btn, currentSlide + 1, currentSlide + this.items, itemSpeed, Math.abs(this.currentSlide - currentSlide));\r\n        }\r\n        else {\r\n            this._setStyle(this.nguItemsContainer.nativeElement, 'transition', ``);\r\n        }\r\n        this.itemLength = this.dataSource.length;\r\n        this._transformStyle(currentSlide);\r\n        this.currentSlide = currentSlide;\r\n        this.onMove.emit(this);\r\n        this._carouselPointActiver();\r\n        this._carouselLoadTrigger();\r\n        this.withAnim = true;\r\n    }\r\n    /** boolean function for making isFirst and isLast */\r\n    _btnBoolean(first, last) {\r\n        this.isFirst = !!first;\r\n        this.isLast = !!last;\r\n    }\r\n    _transformString(grid, slide) {\r\n        let collect = '';\r\n        collect += `${this.styleid} { transform: translate3d(`;\r\n        if (this.vertical.enabled) {\r\n            this.transform[grid] = (this.vertical.height / this.inputs.grid[grid]) * slide;\r\n            collect += `0, -${this.transform[grid]}px, 0`;\r\n        }\r\n        else {\r\n            this.transform[grid] = (100 / this.inputs.grid[grid]) * slide;\r\n            collect += `${this.directionSym}${this.transform[grid]}%, 0, 0`;\r\n        }\r\n        collect += `); }`;\r\n        return collect;\r\n    }\r\n    /** set the transform style to scroll the carousel  */\r\n    _transformStyle(slide) {\r\n        let slideCss = '';\r\n        if (this.type === 'responsive') {\r\n            slideCss = `@media (max-width: 767px) {${this._transformString('xs', slide)}}\r\n      @media (min-width: 768px) {${this._transformString('sm', slide)} }\r\n      @media (min-width: 992px) {${this._transformString('md', slide)} }\r\n      @media (min-width: 1200px) {${this._transformString('lg', slide)} }`;\r\n        }\r\n        else {\r\n            this.transform.all = this.inputs.grid.all * slide;\r\n            slideCss = `${this.styleid} { transform: translate3d(${this.directionSym}${this.transform.all}px, 0, 0);`;\r\n        }\r\n        this.carouselCssNode.innerHTML = slideCss;\r\n    }\r\n    /** this will trigger the carousel to load the items */\r\n    _carouselLoadTrigger() {\r\n        if (typeof this.inputs.load === 'number') {\r\n            this.dataSource.length - this.load <= this.currentSlide + this.items &&\r\n                this.carouselLoad.emit(this.currentSlide);\r\n        }\r\n    }\r\n    /** generate Class for each carousel to set specific style */\r\n    _generateID() {\r\n        let text = '';\r\n        const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n        for (let i = 0; i < 6; i++) {\r\n            text += possible.charAt(Math.floor(Math.random() * possible.length));\r\n        }\r\n        return `ngucarousel${text}`;\r\n    }\r\n    /** handle the auto slide */\r\n    _carouselInterval() {\r\n        const container = this.carouselMain1.nativeElement;\r\n        if (this.interval && this.loop) {\r\n            this.listener4 = this._renderer.listen('window', 'scroll', () => {\r\n                clearTimeout(this.onScrolling);\r\n                this.onScrolling = setTimeout(() => {\r\n                    this._onWindowScrolling();\r\n                }, 600);\r\n            });\r\n            const play$ = fromEvent(container, 'mouseleave').pipe(mapTo(1));\r\n            const pause$ = fromEvent(container, 'mouseenter').pipe(mapTo(0));\r\n            const touchPlay$ = fromEvent(container, 'touchstart').pipe(mapTo(1));\r\n            const touchPause$ = fromEvent(container, 'touchend').pipe(mapTo(0));\r\n            const interval$ = interval(this.inputs.interval.timing).pipe(mapTo(1));\r\n            setTimeout(() => {\r\n                this.carouselInt = merge(play$, touchPlay$, pause$, touchPause$, this._intervalController$)\r\n                    .pipe(startWith(1), switchMap(val => {\r\n                    this.isHovered = !val;\r\n                    this.cdr.markForCheck();\r\n                    return val ? interval$ : EMPTY;\r\n                }))\r\n                    .subscribe(res => {\r\n                    this._carouselScrollOne(1);\r\n                });\r\n            }, this.interval.initialDelay);\r\n        }\r\n    }\r\n    _updateItemIndexContextAni() {\r\n        const viewContainer = this._nodeOutlet.viewContainer;\r\n        for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\r\n            const viewRef = viewContainer.get(renderIndex);\r\n            const context = viewRef.context;\r\n            context.count = count;\r\n            context.first = renderIndex === 0;\r\n            context.last = renderIndex === count - 1;\r\n            context.even = renderIndex % 2 === 0;\r\n            context.odd = !context.even;\r\n            context.index = renderIndex;\r\n        }\r\n    }\r\n    /** animate the carousel items */\r\n    _carouselAnimator(direction, start, end, speed, length, viewContainer = this._nodeOutlet.viewContainer) {\r\n        let val = length < 5 ? length : 5;\r\n        val = val === 1 ? 3 : val;\r\n        const collectIndex = [];\r\n        if (direction === 1) {\r\n            for (let i = start - 1; i < end; i++) {\r\n                collectIndex.push(i);\r\n                val = val * 2;\r\n                const viewRef = viewContainer.get(i);\r\n                const context = viewRef.context;\r\n                context.animate = { value: true, params: { distance: val } };\r\n            }\r\n        }\r\n        else {\r\n            for (let i = end - 1; i >= start - 1; i--) {\r\n                collectIndex.push(i);\r\n                val = val * 2;\r\n                const viewRef = viewContainer.get(i);\r\n                const context = viewRef.context;\r\n                context.animate = { value: true, params: { distance: -val } };\r\n            }\r\n        }\r\n        this.cdr.markForCheck();\r\n        setTimeout(() => {\r\n            this._removeAnimations(collectIndex);\r\n        }, speed * 0.7);\r\n    }\r\n    _removeAnimations(indexs) {\r\n        const viewContainer = this._nodeOutlet.viewContainer;\r\n        indexs.forEach(i => {\r\n            const viewRef = viewContainer.get(i);\r\n            const context = viewRef.context;\r\n            context.animate = { value: false, params: { distance: 0 } };\r\n        });\r\n        this.cdr.markForCheck();\r\n    }\r\n    /** Short form for setElementStyle */\r\n    _setStyle(el, prop, val) {\r\n        this._renderer.setStyle(el, prop, val);\r\n    }\r\n    /** For generating style tag */\r\n    _createStyleElem(datas) {\r\n        const styleItem = this._renderer.createElement('style');\r\n        if (datas) {\r\n            const styleText = this._renderer.createText(datas);\r\n            this._renderer.appendChild(styleItem, styleText);\r\n        }\r\n        this._renderer.appendChild(this.carousel, styleItem);\r\n        return styleItem;\r\n    }\r\n};\r\nNguCarousel.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: Renderer2 },\r\n    { type: IterableDiffers },\r\n    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\r\n    { type: ChangeDetectorRef }\r\n];\r\n__decorate([\r\n    Input()\r\n], NguCarousel.prototype, \"inputs\", void 0);\r\n__decorate([\r\n    Output()\r\n], NguCarousel.prototype, \"carouselLoad\", void 0);\r\n__decorate([\r\n    Output()\r\n], NguCarousel.prototype, \"onMove\", void 0);\r\n__decorate([\r\n    Input('dataSource')\r\n], NguCarousel.prototype, \"dataSource\", null);\r\n__decorate([\r\n    ContentChildren(NguCarouselDefDirective)\r\n], NguCarousel.prototype, \"_defDirec\", void 0);\r\n__decorate([\r\n    ViewChild(NguCarouselOutlet, { static: true })\r\n], NguCarousel.prototype, \"_nodeOutlet\", void 0);\r\n__decorate([\r\n    ContentChild(NguCarouselNextDirective, /* TODO: add static flag */ { read: ElementRef })\r\n], NguCarousel.prototype, \"nextBtn\", null);\r\n__decorate([\r\n    ContentChild(NguCarouselPrevDirective, /* TODO: add static flag */ { read: ElementRef })\r\n], NguCarousel.prototype, \"prevBtn\", null);\r\n__decorate([\r\n    ViewChild('ngucarousel', { read: ElementRef, static: true })\r\n], NguCarousel.prototype, \"carouselMain1\", void 0);\r\n__decorate([\r\n    ViewChild('nguItemsContainer', { read: ElementRef, static: true })\r\n], NguCarousel.prototype, \"nguItemsContainer\", void 0);\r\n__decorate([\r\n    ViewChild('touchContainer', { read: ElementRef, static: true })\r\n], NguCarousel.prototype, \"touchContainer\", void 0);\r\n__decorate([\r\n    Input()\r\n], NguCarousel.prototype, \"trackBy\", null);\r\nNguCarousel = __decorate([\r\n    Component({\r\n        selector: 'ngu-carousel',\r\n        template: \"<div #ngucarousel class=\\\"ngucarousel\\\">\\r\\n  <div #touchContainer class=\\\"ngu-touch-container\\\">\\r\\n    <div #nguItemsContainer class=\\\"ngucarousel-items\\\">\\r\\n      <ng-container nguCarouselOutlet></ng-container>\\r\\n    </div>\\r\\n  </div>\\r\\n  <div class=\\\"nguclearFix\\\"></div>\\r\\n  <ng-content select=\\\"[NguCarouselPrev]\\\"></ng-content>\\r\\n  <ng-content select=\\\"[NguCarouselNext]\\\"></ng-content>\\r\\n</div>\\r\\n<ng-content select=\\\"[NguCarouselPoint]\\\"></ng-content>\\r\\n\",\r\n        changeDetection: ChangeDetectionStrategy.OnPush,\r\n        styles: [\":host{display:block;position:relative}:host.ngurtl{direction:rtl}.ngucarousel{position:relative;overflow:hidden;height:100%}.ngucarousel .ngucarousel-items{position:relative;display:-webkit-box;display:flex;height:100%}.nguvertical{-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column}.banner .ngucarouselPointDefault .ngucarouselPoint{position:absolute;width:100%;bottom:20px}.banner .ngucarouselPointDefault .ngucarouselPoint li{background:rgba(255,255,255,.55)}.banner .ngucarouselPointDefault .ngucarouselPoint li.active{background:#fff}.banner .ngucarouselPointDefault .ngucarouselPoint li:hover{cursor:pointer}.ngucarouselPointDefault .ngucarouselPoint{list-style-type:none;text-align:center;padding:12px;margin:0;white-space:nowrap;overflow:auto;box-sizing:border-box}.ngucarouselPointDefault .ngucarouselPoint li{display:inline-block;border-radius:50%;background:rgba(0,0,0,.55);padding:4px;margin:0 4px;-webkit-transition:.4s;transition:.4s}.ngucarouselPointDefault .ngucarouselPoint li.active{background:#6b6b6b;-webkit-transform:scale(1.8);transform:scale(1.8)}.ngucarouselPointDefault .ngucarouselPoint li:hover{cursor:pointer}.nguclearFix{clear:both}\"]\r\n    })\r\n    // @dynamic\r\n    // tslint:disable-next-line:component-class-suffix\r\n    ,\r\n    __param(3, Inject(PLATFORM_ID))\r\n], NguCarousel);\n\nlet NguItemComponent = class NguItemComponent {\r\n    constructor() {\r\n        this.classes = true;\r\n    }\r\n};\r\n__decorate([\r\n    HostBinding('class.item')\r\n], NguItemComponent.prototype, \"classes\", void 0);\r\nNguItemComponent = __decorate([\r\n    Component({\r\n        selector: 'ngu-item',\r\n        template: \"<ng-content></ng-content>\\r\\n\",\r\n        styles: [\"\"]\r\n    })\r\n], NguItemComponent);\n\nlet NguTileComponent = class NguTileComponent {\r\n    constructor() {\r\n        this.classes = true;\r\n    }\r\n};\r\n__decorate([\r\n    HostBinding('class.item')\r\n], NguTileComponent.prototype, \"classes\", void 0);\r\nNguTileComponent = __decorate([\r\n    Component({\r\n        selector: 'ngu-tile',\r\n        template: \"<div class=\\\"tile\\\">\\r\\n  <ng-content></ng-content>\\r\\n</div>\\r\\n\",\r\n        styles: [\":host{padding:10px;box-sizing:border-box}.tile{box-shadow:0 2px 5px 0 rgba(0,0,0,.16),0 2px 10px 0 rgba(0,0,0,.12)}\"]\r\n    })\r\n], NguTileComponent);\n\nlet NguCarouselModule = class NguCarouselModule {\r\n};\r\nNguCarouselModule = __decorate([\r\n    NgModule({\r\n        imports: [CommonModule],\r\n        exports: [\r\n            NguCarousel,\r\n            NguItemComponent,\r\n            NguTileComponent,\r\n            NguCarouselPointDirective,\r\n            NguCarouselItemDirective,\r\n            NguCarouselNextDirective,\r\n            NguCarouselPrevDirective,\r\n            NguCarouselDefDirective,\r\n            NguCarouselOutlet\r\n        ],\r\n        declarations: [\r\n            NguCarousel,\r\n            NguItemComponent,\r\n            NguTileComponent,\r\n            NguCarouselPointDirective,\r\n            NguCarouselItemDirective,\r\n            NguCarouselNextDirective,\r\n            NguCarouselPrevDirective,\r\n            NguCarouselDefDirective,\r\n            NguCarouselOutlet\r\n        ]\r\n    })\r\n], NguCarouselModule);\n\n/*\r\n * Public API Surface of carousel\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { NguCarousel, NguCarouselConfig, NguCarouselDefDirective, NguCarouselItemDirective, NguCarouselModule, NguCarouselNextDirective, NguCarouselOutlet, NguCarouselPointDirective, NguCarouselPrevDirective, NguCarouselStore, NguItemComponent, NguTileComponent, ItemsControl as ɵa, NguButton as ɵb };\n"]}