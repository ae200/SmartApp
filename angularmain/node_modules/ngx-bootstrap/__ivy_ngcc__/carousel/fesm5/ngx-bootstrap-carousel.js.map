{"version":3,"sources":["C:/Users/Administrator/Desktop/work/angular/smartapp/node_modules/ngx-bootstrap/carousel/fesm5/ngx-bootstrap-carousel.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;KAmBK;;;;;sLAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAypCA,AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoIA,AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA2CA;;;;;;;;;;;;;;0CAQA","file":"ngx-bootstrap-carousel.js","sourcesContent":["import { __spread } from 'tslib';\nimport { Injectable, EventEmitter, Component, NgZone, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3 } from 'ngx-bootstrap/utils';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar CarouselConfig = /** @class */ (function () {\n    function CarouselConfig() {\n        /* Default interval of auto changing of slides */\n        this.interval = 5000;\n        /* Is loop of auto changing of slides can be paused */\n        this.noPause = false;\n        /* Is slides can wrap from the last to the first slide */\n        this.noWrap = false;\n        /* Show carousel-indicators */\n        this.showIndicators = true;\n        /* Slides can be paused on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n            of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n    }\n    CarouselConfig.decorators = [\n        { type: Injectable }\n    ];\n    return CarouselConfig;\n}());\nif (false) {\n    /** @type {?} */\n    CarouselConfig.prototype.interval;\n    /** @type {?} */\n    CarouselConfig.prototype.noPause;\n    /** @type {?} */\n    CarouselConfig.prototype.noWrap;\n    /** @type {?} */\n    CarouselConfig.prototype.showIndicators;\n    /** @type {?} */\n    CarouselConfig.prototype.pauseOnFocus;\n    /** @type {?} */\n    CarouselConfig.prototype.indicatorsByChunk;\n    /** @type {?} */\n    CarouselConfig.prototype.itemsPerSlide;\n    /** @type {?} */\n    CarouselConfig.prototype.singleSlideOffset;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @template T\n * @param {?} array The source array to search in\n * @param {?} predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n * @return {?}\n */\nfunction findLastIndex(array, predicate) {\n    /** @type {?} */\n    var l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) {\n            return l;\n        }\n    }\n    return -1;\n}\n/**\n * @template T\n * @param {?} array\n * @param {?} size\n * @return {?}\n */\nfunction chunkByNumber(array, size) {\n    /** @type {?} */\n    var out = [];\n    /** @type {?} */\n    var n = Math.ceil((array.length) / size);\n    /** @type {?} */\n    var i = 0;\n    while (i < n) {\n        /** @type {?} */\n        var chunk = array.splice(0, (i === n - 1) && size < array.length ? array.length : size);\n        out.push(chunk);\n        i++;\n    }\n    return out;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nvar Direction = {\n    UNKNOWN: 0,\n    NEXT: 1,\n    PREV: 2,\n};\nDirection[Direction.UNKNOWN] = 'UNKNOWN';\nDirection[Direction.NEXT] = 'NEXT';\nDirection[Direction.PREV] = 'PREV';\n/**\n * Base element to create carousel\n */\nvar CarouselComponent = /** @class */ (function () {\n    function CarouselComponent(config, ngZone) {\n        this.ngZone = ngZone;\n        /* If `true` - carousel indicators indicate slides chunks\n             works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n             of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n        /**\n         * Turn on/off animation. Animation doesn't work for multilist carousel\n         */\n        this.isAnimated = false;\n        /**\n         * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n         */\n        this.activeSlideChange = new EventEmitter(false);\n        /**\n         * Will be emitted when active slides has been changed in multilist mode\n         */\n        this.slideRangeChange = new EventEmitter();\n        /* Index to start display slides from it */\n        this.startFromIndex = 0;\n        this._slides = new LinkedList();\n        this._currentVisibleSlidesIndex = 0;\n        this.destroyed = false;\n        this.getActive = (/**\n         * @param {?} slide\n         * @return {?}\n         */\n        function (slide) { return slide.active; });\n        this.makeSlidesConsistent = (/**\n         * @param {?} slides\n         * @return {?}\n         */\n        function (slides) {\n            slides.forEach((/**\n             * @param {?} slide\n             * @param {?} index\n             * @return {?}\n             */\n            function (slide, index) { return slide.item.order = index; }));\n        });\n        Object.assign(this, config);\n    }\n    Object.defineProperty(CarouselComponent.prototype, \"activeSlide\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this._currentActiveSlide;\n        },\n        /** Index of currently displayed slide(started for 0) */\n        set: /**\n         * Index of currently displayed slide(started for 0)\n         * @param {?} index\n         * @return {?}\n         */\n        function (index) {\n            if (this.multilist) {\n                return;\n            }\n            if (this._slides.length && index !== this._currentActiveSlide) {\n                this._select(index);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CarouselComponent.prototype, \"interval\", {\n        /**\n         * Delay of item cycling in milliseconds. If false, carousel won't cycle\n         * automatically.\n         */\n        get: /**\n         * Delay of item cycling in milliseconds. If false, carousel won't cycle\n         * automatically.\n         * @return {?}\n         */\n        function () {\n            return this._interval;\n        },\n        set: /**\n         * @param {?} value\n         * @return {?}\n         */\n        function (value) {\n            this._interval = value;\n            this.restartTimer();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CarouselComponent.prototype, \"slides\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this._slides.toArray();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CarouselComponent.prototype, \"isBs4\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return !isBs3();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.ngAfterViewInit = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        setTimeout((/**\n         * @return {?}\n         */\n        function () {\n            if (_this.singleSlideOffset) {\n                _this.indicatorsByChunk = false;\n            }\n            if (_this.multilist) {\n                _this._chunkedSlides = chunkByNumber(_this.mapSlidesAndIndexes(), _this.itemsPerSlide);\n                _this.selectInitialSlides();\n            }\n        }), 0);\n    };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n    function () {\n        this.destroyed = true;\n    };\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param slide\n     */\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param {?} slide\n     * @return {?}\n     */\n    CarouselComponent.prototype.addSlide = /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param {?} slide\n     * @return {?}\n     */\n    function (slide) {\n        this._slides.add(slide);\n        if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n            slide.active = true;\n        }\n        if (!this.multilist && this.isAnimated) {\n            slide.isAnimated = true;\n        }\n        if (!this.multilist && this._slides.length === 1) {\n            this._currentActiveSlide = undefined;\n            this.activeSlide = 0;\n            this.play();\n        }\n        if (this.multilist && this._slides.length > this.itemsPerSlide) {\n            this.play();\n        }\n    };\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param slide\n     */\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param {?} slide\n     * @return {?}\n     */\n    CarouselComponent.prototype.removeSlide = /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param {?} slide\n     * @return {?}\n     */\n    function (slide) {\n        var _this = this;\n        /** @type {?} */\n        var remIndex = this._slides.indexOf(slide);\n        if (this._currentActiveSlide === remIndex) {\n            // removing of active slide\n            /** @type {?} */\n            var nextSlideIndex_1 = void 0;\n            if (this._slides.length > 1) {\n                // if this slide last - will roll to first slide, if noWrap flag is\n                // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n                // middle of collection, index of next slide is same to removed\n                nextSlideIndex_1 = !this.isLast(remIndex)\n                    ? remIndex\n                    : this.noWrap ? remIndex - 1 : 0;\n            }\n            this._slides.remove(remIndex);\n            // prevents exception with changing some value after checking\n            setTimeout((/**\n             * @return {?}\n             */\n            function () {\n                _this._select(nextSlideIndex_1);\n            }), 0);\n        }\n        else {\n            this._slides.remove(remIndex);\n            /** @type {?} */\n            var currentSlideIndex_1 = this.getCurrentSlideIndex();\n            setTimeout((/**\n             * @return {?}\n             */\n            function () {\n                // after removing, need to actualize index of current active slide\n                _this._currentActiveSlide = currentSlideIndex_1;\n                _this.activeSlideChange.emit(_this._currentActiveSlide);\n            }), 0);\n        }\n    };\n    /**\n     * @param {?=} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.nextSlideFromInterval = /**\n     * @param {?=} force\n     * @return {?}\n     */\n    function (force) {\n        if (force === void 0) { force = false; }\n        this.move(Direction.NEXT, force);\n    };\n    /**\n     * Rolling to next slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    /**\n     * Rolling to next slide\n     * @param {?=} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.nextSlide = /**\n     * Rolling to next slide\n     * @param {?=} force\n     * @return {?}\n     */\n    function (force) {\n        if (force === void 0) { force = false; }\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.NEXT, force);\n    };\n    /**\n     * Rolling to previous slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    /**\n     * Rolling to previous slide\n     * @param {?=} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.previousSlide = /**\n     * Rolling to previous slide\n     * @param {?=} force\n     * @return {?}\n     */\n    function (force) {\n        if (force === void 0) { force = false; }\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.PREV, force);\n    };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.getFirstVisibleIndex = /**\n     * @return {?}\n     */\n    function () {\n        return this.slides.findIndex(this.getActive);\n    };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.getLastVisibleIndex = /**\n     * @return {?}\n     */\n    function () {\n        return findLastIndex(this.slides, this.getActive);\n    };\n    /**\n     * @param {?} direction\n     * @param {?=} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.move = /**\n     * @param {?} direction\n     * @param {?=} force\n     * @return {?}\n     */\n    function (direction, force) {\n        if (force === void 0) { force = false; }\n        /** @type {?} */\n        var firstVisibleIndex = this.getFirstVisibleIndex();\n        /** @type {?} */\n        var lastVisibleIndex = this.getLastVisibleIndex();\n        if (this.noWrap) {\n            if (direction === Direction.NEXT &&\n                this.isLast(lastVisibleIndex) ||\n                direction === Direction.PREV &&\n                    firstVisibleIndex === 0) {\n                return;\n            }\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.findNextSlideIndex(direction, force);\n        }\n        else {\n            this.moveMultilist(direction);\n        }\n    };\n    /**\n     * Swith slides by enter, space and arrows keys\n     * @internal\n     */\n    /**\n     * Swith slides by enter, space and arrows keys\n     * \\@internal\n     * @param {?} event\n     * @return {?}\n     */\n    CarouselComponent.prototype.keydownPress = /**\n     * Swith slides by enter, space and arrows keys\n     * \\@internal\n     * @param {?} event\n     * @return {?}\n     */\n    function (event) {\n        // tslint:disable-next-line:deprecation\n        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n            this.nextSlide();\n            event.preventDefault();\n            return;\n        }\n        // tslint:disable-next-line:deprecation\n        if (event.keyCode === 37 || event.key === 'LeftArrow') {\n            this.previousSlide();\n            return;\n        }\n        // tslint:disable-next-line:deprecation\n        if (event.keyCode === 39 || event.key === 'RightArrow') {\n            this.nextSlide();\n            return;\n        }\n    };\n    /**\n     * Play on mouse leave\n     * @internal\n     */\n    /**\n     * Play on mouse leave\n     * \\@internal\n     * @return {?}\n     */\n    CarouselComponent.prototype.onMouseLeave = /**\n     * Play on mouse leave\n     * \\@internal\n     * @return {?}\n     */\n    function () {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    };\n    /**\n     * Play on mouse up\n     * @internal\n     */\n    /**\n     * Play on mouse up\n     * \\@internal\n     * @return {?}\n     */\n    CarouselComponent.prototype.onMouseUp = /**\n     * Play on mouse up\n     * \\@internal\n     * @return {?}\n     */\n    function () {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    };\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * @internal\n     */\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * \\@internal\n     * @return {?}\n     */\n    CarouselComponent.prototype.pauseFocusIn = /**\n     * When slides on focus autoplay is stopped(optional)\n     * \\@internal\n     * @return {?}\n     */\n    function () {\n        if (this.pauseOnFocus) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    };\n    /**\n     * When slides out of focus autoplay is started\n     * @internal\n     */\n    /**\n     * When slides out of focus autoplay is started\n     * \\@internal\n     * @return {?}\n     */\n    CarouselComponent.prototype.pauseFocusOut = /**\n     * When slides out of focus autoplay is started\n     * \\@internal\n     * @return {?}\n     */\n    function () {\n        this.play();\n    };\n    /**\n     * Rolling to specified slide\n     * @param index: {number} index of slide, which must be shown\n     */\n    /**\n     * Rolling to specified slide\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.selectSlide = /**\n     * Rolling to specified slide\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n        }\n        else {\n            this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n        }\n    };\n    /**\n     * Starts a auto changing of slides\n     */\n    /**\n     * Starts a auto changing of slides\n     * @return {?}\n     */\n    CarouselComponent.prototype.play = /**\n     * Starts a auto changing of slides\n     * @return {?}\n     */\n    function () {\n        if (!this.isPlaying) {\n            this.isPlaying = true;\n            this.restartTimer();\n        }\n    };\n    /**\n     * Stops a auto changing of slides\n     */\n    /**\n     * Stops a auto changing of slides\n     * @return {?}\n     */\n    CarouselComponent.prototype.pause = /**\n     * Stops a auto changing of slides\n     * @return {?}\n     */\n    function () {\n        if (!this.noPause) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    };\n    /**\n     * Finds and returns index of currently displayed slide\n     */\n    /**\n     * Finds and returns index of currently displayed slide\n     * @return {?}\n     */\n    CarouselComponent.prototype.getCurrentSlideIndex = /**\n     * Finds and returns index of currently displayed slide\n     * @return {?}\n     */\n    function () {\n        return this._slides.findIndex(this.getActive);\n    };\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param index\n     */\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.isLast = /**\n     * Defines, whether the specified index is last in collection\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        return index + 1 >= this._slides.length;\n    };\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param index\n     */\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.isFirst = /**\n     * Defines, whether the specified index is first in collection\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        return index === 0;\n    };\n    /**\n     * @return {?}\n     */\n    CarouselComponent.prototype.indicatorsSlides = /**\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        return this.slides.filter((/**\n         * @param {?} slide\n         * @param {?} index\n         * @return {?}\n         */\n        function (slide, index) { return !_this.indicatorsByChunk || index % _this.itemsPerSlide === 0; }));\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    CarouselComponent.prototype.selectInitialSlides = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var startIndex = this.startFromIndex <= this._slides.length\n            ? this.startFromIndex\n            : 0;\n        this.hideSlides();\n        if (this.singleSlideOffset) {\n            this._slidesWithIndexes = this.mapSlidesAndIndexes();\n            if (this._slides.length - startIndex < this.itemsPerSlide) {\n                /** @type {?} */\n                var slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n                this._slidesWithIndexes = __spread(this._slidesWithIndexes, slidesToAppend).slice(slidesToAppend.length)\n                    .slice(0, this.itemsPerSlide);\n            }\n            else {\n                this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n            }\n            this._slidesWithIndexes.forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            function (slide) { return slide.item.active = true; }));\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n        }\n        else {\n            this.selectRangeByNestedIndex(startIndex);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    };\n    /**\n     * Defines next slide index, depending of direction\n     * @param direction: Direction(UNKNOWN|PREV|NEXT)\n     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n     *   return undefined if next slide require wrapping\n     */\n    /**\n     * Defines next slide index, depending of direction\n     * @private\n     * @param {?} direction\n     * @param {?} force\n     * @return {?}\n     */\n    CarouselComponent.prototype.findNextSlideIndex = /**\n     * Defines next slide index, depending of direction\n     * @private\n     * @param {?} direction\n     * @param {?} force\n     * @return {?}\n     */\n    function (direction, force) {\n        /** @type {?} */\n        var nextSlideIndex = 0;\n        if (!force &&\n            (this.isLast(this.activeSlide) &&\n                direction !== Direction.PREV &&\n                this.noWrap)) {\n            return undefined;\n        }\n        switch (direction) {\n            case Direction.NEXT:\n                // if this is last slide, not force, looping is disabled\n                // and need to going forward - select current slide, as a next\n                nextSlideIndex = !this.isLast(this._currentActiveSlide)\n                    ? this._currentActiveSlide + 1\n                    : !force && this.noWrap ? this._currentActiveSlide : 0;\n                break;\n            case Direction.PREV:\n                // if this is first slide, not force, looping is disabled\n                // and need to going backward - select current slide, as a next\n                nextSlideIndex =\n                    this._currentActiveSlide > 0\n                        ? this._currentActiveSlide - 1\n                        : !force && this.noWrap\n                            ? this._currentActiveSlide\n                            : this._slides.length - 1;\n                break;\n            default:\n                throw new Error('Unknown direction');\n        }\n        return nextSlideIndex;\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    CarouselComponent.prototype.mapSlidesAndIndexes = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        return this.slides\n            .slice()\n            .map((/**\n         * @param {?} slide\n         * @param {?} index\n         * @return {?}\n         */\n        function (slide, index) {\n            return {\n                index: index,\n                item: slide\n            };\n        }));\n    };\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.selectSlideRange = /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.isIndexInRange(index)) {\n            return;\n        }\n        this.hideSlides();\n        if (!this.singleSlideOffset) {\n            this.selectRangeByNestedIndex(index);\n        }\n        else {\n            /** @type {?} */\n            var startIndex = this.isIndexOnTheEdges(index)\n                ? index\n                : index - this.itemsPerSlide + 1;\n            /** @type {?} */\n            var endIndex = this.isIndexOnTheEdges(index)\n                ? index + this.itemsPerSlide\n                : index + 1;\n            this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n            this._slidesWithIndexes.forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            function (slide) { return slide.item.active = true; }));\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    };\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.selectRangeByNestedIndex = /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        /** @type {?} */\n        var selectedRange = this._chunkedSlides\n            .map((/**\n         * @param {?} slidesList\n         * @param {?} i\n         * @return {?}\n         */\n        function (slidesList, i) {\n            return {\n                index: i,\n                list: slidesList\n            };\n        }))\n            .find((/**\n         * @param {?} slidesList\n         * @return {?}\n         */\n        function (slidesList) {\n            return slidesList.list.find((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            function (slide) { return slide.index === index; })) !== undefined;\n        }));\n        this._currentVisibleSlidesIndex = selectedRange.index;\n        this._chunkedSlides[selectedRange.index].forEach((/**\n         * @param {?} slide\n         * @return {?}\n         */\n        function (slide) {\n            slide.item.active = true;\n        }));\n    };\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.isIndexOnTheEdges = /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        return (index + 1 - this.itemsPerSlide <= 0 ||\n            index + this.itemsPerSlide <= this._slides.length);\n    };\n    /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype.isIndexInRange = /**\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (this.singleSlideOffset) {\n            /** @type {?} */\n            var visibleIndexes = this._slidesWithIndexes.map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            function (slide) { return slide.index; }));\n            return visibleIndexes.indexOf(index) >= 0;\n        }\n        return (index <= this.getLastVisibleIndex() &&\n            index >= this.getFirstVisibleIndex());\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    CarouselComponent.prototype.hideSlides = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        this.slides.forEach((/**\n         * @param {?} slide\n         * @return {?}\n         */\n        function (slide) { return slide.active = false; }));\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    CarouselComponent.prototype.isVisibleSlideListLast = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    CarouselComponent.prototype.isVisibleSlideListFirst = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        return this._currentVisibleSlidesIndex === 0;\n    };\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n    CarouselComponent.prototype.moveSliderByOneItem = /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n    function (direction) {\n        /** @type {?} */\n        var firstVisibleIndex;\n        /** @type {?} */\n        var lastVisibleIndex;\n        /** @type {?} */\n        var indexToHide;\n        /** @type {?} */\n        var indexToShow;\n        if (this.noWrap) {\n            firstVisibleIndex = this.getFirstVisibleIndex();\n            lastVisibleIndex = this.getLastVisibleIndex();\n            indexToHide = direction === Direction.NEXT\n                ? firstVisibleIndex\n                : lastVisibleIndex;\n            indexToShow = direction !== Direction.NEXT\n                ? firstVisibleIndex - 1\n                : !this.isLast(lastVisibleIndex)\n                    ? lastVisibleIndex + 1 : 0;\n            this._slides.get(indexToHide).active = false;\n            this._slides.get(indexToShow).active = true;\n            /** @type {?} */\n            var slidesToReorder = this.mapSlidesAndIndexes().filter((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            function (slide) { return slide.item.active; }));\n            this.makeSlidesConsistent(slidesToReorder);\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n        }\n        else {\n            /** @type {?} */\n            var displayedIndex = void 0;\n            firstVisibleIndex = this._slidesWithIndexes[0].index;\n            lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n            if (direction === Direction.NEXT) {\n                this._slidesWithIndexes.shift();\n                displayedIndex = this.isLast(lastVisibleIndex)\n                    ? 0\n                    : lastVisibleIndex + 1;\n                this._slidesWithIndexes.push({\n                    index: displayedIndex,\n                    item: this._slides.get(displayedIndex)\n                });\n            }\n            else {\n                this._slidesWithIndexes.pop();\n                displayedIndex = this.isFirst(firstVisibleIndex)\n                    ? this._slides.length - 1\n                    : firstVisibleIndex - 1;\n                this._slidesWithIndexes = __spread([{\n                        index: displayedIndex,\n                        item: this._slides.get(displayedIndex)\n                    }], this._slidesWithIndexes);\n            }\n            this.hideSlides();\n            this._slidesWithIndexes.forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            function (slide) { return slide.item.active = true; }));\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n            this.slideRangeChange.emit(this._slidesWithIndexes.map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            function (slide) { return slide.index; })));\n        }\n    };\n    /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n    CarouselComponent.prototype.moveMultilist = /**\n     * @private\n     * @param {?} direction\n     * @return {?}\n     */\n    function (direction) {\n        if (this.singleSlideOffset) {\n            this.moveSliderByOneItem(direction);\n        }\n        else {\n            this.hideSlides();\n            if (this.noWrap) {\n                this._currentVisibleSlidesIndex = direction === Direction.NEXT\n                    ? this._currentVisibleSlidesIndex + 1\n                    : this._currentVisibleSlidesIndex - 1;\n            }\n            else {\n                if (direction === Direction.NEXT) {\n                    this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n                        ? 0\n                        : this._currentVisibleSlidesIndex + 1;\n                }\n                else {\n                    this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst()\n                        ? this._chunkedSlides.length - 1\n                        : this._currentVisibleSlidesIndex - 1;\n                }\n            }\n            this._chunkedSlides[this._currentVisibleSlidesIndex].forEach((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            function (slide) { return slide.item.active = true; }));\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n        }\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    CarouselComponent.prototype.getVisibleIndexes = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (!this.singleSlideOffset) {\n            return this._chunkedSlides[this._currentVisibleSlidesIndex]\n                .map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            function (slide) { return slide.index; }));\n        }\n        else {\n            return this._slidesWithIndexes.map((/**\n             * @param {?} slide\n             * @return {?}\n             */\n            function (slide) { return slide.index; }));\n        }\n    };\n    /**\n     * Sets a slide, which specified through index, as active\n     * @param index\n     */\n    /**\n     * Sets a slide, which specified through index, as active\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    CarouselComponent.prototype._select = /**\n     * Sets a slide, which specified through index, as active\n     * @private\n     * @param {?} index\n     * @return {?}\n     */\n    function (index) {\n        if (isNaN(index)) {\n            this.pause();\n            return;\n        }\n        if (!this.multilist) {\n            /** @type {?} */\n            var currentSlide = this._slides.get(this._currentActiveSlide);\n            if (currentSlide) {\n                currentSlide.active = false;\n            }\n        }\n        /** @type {?} */\n        var nextSlide = this._slides.get(index);\n        if (nextSlide) {\n            this._currentActiveSlide = index;\n            nextSlide.active = true;\n            this.activeSlide = index;\n            this.activeSlideChange.emit(index);\n        }\n    };\n    /**\n     * Starts loop of auto changing of slides\n     */\n    /**\n     * Starts loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n    CarouselComponent.prototype.restartTimer = /**\n     * Starts loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.resetTimer();\n        /** @type {?} */\n        var interval = +this.interval;\n        if (!isNaN(interval) && interval > 0) {\n            this.currentInterval = this.ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            function () {\n                return setInterval((/**\n                 * @return {?}\n                 */\n                function () {\n                    /** @type {?} */\n                    var nInterval = +_this.interval;\n                    _this.ngZone.run((/**\n                     * @return {?}\n                     */\n                    function () {\n                        if (_this.isPlaying &&\n                            !isNaN(_this.interval) &&\n                            nInterval > 0 &&\n                            _this.slides.length) {\n                            _this.nextSlideFromInterval();\n                        }\n                        else {\n                            _this.pause();\n                        }\n                    }));\n                }), interval);\n            }));\n        }\n    };\n    Object.defineProperty(CarouselComponent.prototype, \"multilist\", {\n        get: /**\n         * @return {?}\n         */\n        function () {\n            return this.itemsPerSlide > 1;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Stops loop of auto changing of slides\n     */\n    /**\n     * Stops loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n    CarouselComponent.prototype.resetTimer = /**\n     * Stops loop of auto changing of slides\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (this.currentInterval) {\n            clearInterval(this.currentInterval);\n            this.currentInterval = void 0;\n        }\n    };\n    CarouselComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'carousel',\n                    template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ol class=\\\"carousel-indicators\\\" *ngIf=\\\"showIndicators && slides.length > 1\\\">\\n    <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\">\\n    </li>\\n  </ol>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     [class.disabled]=\\\"activeSlide === 0 && noWrap\\\"\\n     (click)=\\\"previousSlide()\\\" *ngIf=\\\"slides.length > 1\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     [class.disabled]=\\\"isLast(activeSlide) && noWrap\\\"\\n     (click)=\\\"nextSlide()\\\" *ngIf=\\\"slides.length > 1\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only\\\">Next</span>\\n  </a>\\n</div>\\n\"\n                }] }\n    ];\n    /** @nocollapse */\n    CarouselComponent.ctorParameters = function () { return [\n        { type: CarouselConfig },\n        { type: NgZone }\n    ]; };\n    CarouselComponent.propDecorators = {\n        noWrap: [{ type: Input }],\n        noPause: [{ type: Input }],\n        showIndicators: [{ type: Input }],\n        pauseOnFocus: [{ type: Input }],\n        indicatorsByChunk: [{ type: Input }],\n        itemsPerSlide: [{ type: Input }],\n        singleSlideOffset: [{ type: Input }],\n        isAnimated: [{ type: Input }],\n        activeSlideChange: [{ type: Output }],\n        slideRangeChange: [{ type: Output }],\n        activeSlide: [{ type: Input }],\n        startFromIndex: [{ type: Input }],\n        interval: [{ type: Input }]\n    };\n    return CarouselComponent;\n}());\nif (false) {\n    /** @type {?} */\n    CarouselComponent.prototype.noWrap;\n    /** @type {?} */\n    CarouselComponent.prototype.noPause;\n    /** @type {?} */\n    CarouselComponent.prototype.showIndicators;\n    /** @type {?} */\n    CarouselComponent.prototype.pauseOnFocus;\n    /** @type {?} */\n    CarouselComponent.prototype.indicatorsByChunk;\n    /** @type {?} */\n    CarouselComponent.prototype.itemsPerSlide;\n    /** @type {?} */\n    CarouselComponent.prototype.singleSlideOffset;\n    /**\n     * Turn on/off animation. Animation doesn't work for multilist carousel\n     * @type {?}\n     */\n    CarouselComponent.prototype.isAnimated;\n    /**\n     * Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property\n     * @type {?}\n     */\n    CarouselComponent.prototype.activeSlideChange;\n    /**\n     * Will be emitted when active slides has been changed in multilist mode\n     * @type {?}\n     */\n    CarouselComponent.prototype.slideRangeChange;\n    /** @type {?} */\n    CarouselComponent.prototype.startFromIndex;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype.currentInterval;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._currentActiveSlide;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._interval;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._slides;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._chunkedSlides;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._slidesWithIndexes;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype._currentVisibleSlidesIndex;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype.isPlaying;\n    /**\n     * @type {?}\n     * @protected\n     */\n    CarouselComponent.prototype.destroyed;\n    /** @type {?} */\n    CarouselComponent.prototype.getActive;\n    /**\n     * @type {?}\n     * @private\n     */\n    CarouselComponent.prototype.makeSlidesConsistent;\n    /**\n     * @type {?}\n     * @private\n     */\n    CarouselComponent.prototype.ngZone;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar SlideComponent = /** @class */ (function () {\n    function SlideComponent(carousel) {\n        this.itemWidth = '100%';\n        this.order = 0;\n        /**\n         * Wraps element by appropriate CSS classes\n         */\n        this.addClass = true;\n        this.carousel = carousel;\n    }\n    /** Fires changes in container collection after adding a new slide instance */\n    /**\n     * Fires changes in container collection after adding a new slide instance\n     * @return {?}\n     */\n    SlideComponent.prototype.ngOnInit = /**\n     * Fires changes in container collection after adding a new slide instance\n     * @return {?}\n     */\n    function () {\n        this.carousel.addSlide(this);\n        this.itemWidth = 100 / this.carousel.itemsPerSlide + \"%\";\n    };\n    /** Fires changes in container collection after removing of this slide instance */\n    /**\n     * Fires changes in container collection after removing of this slide instance\n     * @return {?}\n     */\n    SlideComponent.prototype.ngOnDestroy = /**\n     * Fires changes in container collection after removing of this slide instance\n     * @return {?}\n     */\n    function () {\n        this.carousel.removeSlide(this);\n    };\n    SlideComponent.decorators = [\n        { type: Component, args: [{\n                    selector: 'slide',\n                    template: \"\\n    <div [class.active]=\\\"active\\\" class=\\\"item\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  \",\n                    host: {\n                        '[attr.aria-hidden]': '!active'\n                    },\n                    styles: [\"\\n    :host.carousel-animation {\\n       transition: opacity 0.6s ease, visibility 0.6s ease;\\n       float: left;\\n    }\\n    :host.carousel-animation.active {\\n      opacity: 1;\\n      visibility: visible;\\n    }\\n    :host.carousel-animation:not(.active) {\\n      display: block;\\n      position: absolute;\\n      opacity: 0;\\n      visibility: hidden;\\n    }\\n  \"]\n                }] }\n    ];\n    /** @nocollapse */\n    SlideComponent.ctorParameters = function () { return [\n        { type: CarouselComponent }\n    ]; };\n    SlideComponent.propDecorators = {\n        active: [{ type: HostBinding, args: ['class.active',] }, { type: Input }],\n        itemWidth: [{ type: HostBinding, args: ['style.width',] }],\n        order: [{ type: HostBinding, args: ['style.order',] }],\n        isAnimated: [{ type: HostBinding, args: ['class.carousel-animation',] }],\n        addClass: [{ type: HostBinding, args: ['class.item',] }, { type: HostBinding, args: ['class.carousel-item',] }]\n    };\n    return SlideComponent;\n}());\nif (false) {\n    /**\n     * Is current slide active\n     * @type {?}\n     */\n    SlideComponent.prototype.active;\n    /** @type {?} */\n    SlideComponent.prototype.itemWidth;\n    /** @type {?} */\n    SlideComponent.prototype.order;\n    /** @type {?} */\n    SlideComponent.prototype.isAnimated;\n    /**\n     * Wraps element by appropriate CSS classes\n     * @type {?}\n     */\n    SlideComponent.prototype.addClass;\n    /**\n     * Link to Parent(container-collection) component\n     * @type {?}\n     * @protected\n     */\n    SlideComponent.prototype.carousel;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar CarouselModule = /** @class */ (function () {\n    function CarouselModule() {\n    }\n    /**\n     * @return {?}\n     */\n    CarouselModule.forRoot = /**\n     * @return {?}\n     */\n    function () {\n        return { ngModule: CarouselModule, providers: [] };\n    };\n    CarouselModule.decorators = [\n        { type: NgModule, args: [{\n                    imports: [CommonModule],\n                    declarations: [SlideComponent, CarouselComponent],\n                    exports: [SlideComponent, CarouselComponent],\n                    providers: [CarouselConfig]\n                },] }\n    ];\n    return CarouselModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };\n"]}